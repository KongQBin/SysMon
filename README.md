# SysMon
**这是一个利用ptrace实现的系统监控项目，灵感来源于系统调用追踪工具strace。**

## 说明及注意事项
### 说明
* PTRACE_POKEDATA：该标志用于将数据写入被跟踪进程的内存。
> 你可以使用它来修改进程的数据段（data segment）或堆（heap）中的任意内存位置。
>> 例如，你可以使用它来修改程序中的变量值或函数的参数。
 
* PTRACE_POKETEXT：该标志用于将指令写入被跟踪进程的内存。
> 你可以使用它来修改进程的代码段（text segment）中的指令。
> 通过修改指令，你可以实现一些代码注入或代码替换的操作。
> 这在进行动态调试或代码修复时可能会有用。
 
* PTRACE_POKEUSER：该标志用于修改被跟踪进程的用户寄存器（user registers）。
> 用户寄存器包括程序计数器（program counter）、堆栈指针（stack pointer）和其他一些与进程状态相关的寄存器。
> 通过修改这些寄存器的值，你可以对进程的执行流程进行精确控制，例如修改函数调用栈或返回地址等。

### 注意事项
#### 一：
- 当使用PTRACE_POKEDATA修改某个系统调用的字符串参数时，务必保证新字符串长度小于等于原字符串长度，否则会出现以下两种情况
	- 情况1：如果原字符串在数据段，新字符串长度超出，会导致破坏原数据段数据，或其它不可预知的错误，{就比如在我本地while循环中有{write，printf}，这两个系统调用使用的参数均在数据段，当我修改write使用的的新字符串长度超出原字符串长度的时候，就出现了不调用下一次的系统调用（printf）的问题}
	- 情况2：如果原字符串在堆区，新字符串长度超出，大概率会导致段错误

#### 二：
- 当被修改的数据在数据段
	- 修改会是永久的，只有在下次目标进程重新启动数据才会还原
	- 另外个人猜测如果是动态库的话，则需要使用该动态库的进程全部退出，系统将动态库从内存中释放，然后重新启动各个进程，将动态库重新加载进内存，数据才会被还原
- 当被修改的数据在堆区则有两种情况
	- 情况1：该堆区变量仅被赋值过一次，则现象与修改数据段数据一致
	- 情况2：该堆区变量被赋值过多次，则需要重复修改，才能保证该进程一直使用的是你所修改的数据

#### 三：
- 当被修改的数据是值拷贝传递，那么修改该数据不会影响程序下一次使用该参数
	- 就比如修改write函数中的参数1，也就是fd的值，并不会造成后续调用close导致文件描述符泄漏的问题

## 设计思路
- 多线程
	- 每个线程利用ptrace对系统中的部分线程进行追踪，随后分别调用wait(-1)
		- 举例：线程A追踪系统中的线程1、2、3，线程B追踪系统中的线程4、5、6，然后分别调用wait(-1)
		- 现象：线程A wait到了线程B所追踪的线程4的事件，线程B也会 wait到线程A所追踪的线程，但线程A、B均无法利用ptrace对追踪到的对方的事件进行处理
		- 举例：鉴于前者的现象，线程A、B均将wait(-1)改为waitid(P_PGID
                - 现象：当被监控的线程进行了fork，存在不监控新建进程组的问题，需要另外拉起一个线程去等待新创建的进程组，否则新的进程组会一直阻塞
	- 单个线程负责利用ptrace进行追踪、读取寄存器、放行，其它线程负责wait、通知主线程读取寄存器、拿到寄存器的参数进行分析和处理、通知主线程放行
- 多进程
	- 每个进程追踪系统中的一个进程组或多个进程组
- 多线程搭配多进程

## 优化思路
- 协程
	- 每个协程利用ptrace对系统中的部分线程进行追踪，随后分别调用wait(-1)
- c++ 20/23 或者libgo等相关库
- go 的原生协程与C/C++混编

# PS
- 对于上述对被追踪的进程线程的描述中，由于内核中不存在线程的概念，应用层的线程实际时内核中的进程，应用层中的进程实际是内核中的进程组，故描述可能会有混淆，理解大概意思即可
