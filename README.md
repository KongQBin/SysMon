# SysMon
**这是一个利用ptrace实现的系统监控项目，灵感来源于系统调用追踪工具strace。**
**经验证，用于监控整个系统时性能不及预期，遂Pass，若没有特殊需求，将不再进行后续开发。**
**main分支即是最新代码，不建议在Ubuntu系统中测试，因为对seccomp安全机制未做兼容性处理！！**

## 设计思路
- 多线程(经过验证，性能奇差，事件频繁在多个线程之间切换的性能损失远远超过多线程带来的性能提升)
	- 每个线程利用ptrace对系统中的部分线程进行追踪，随后分别调用wait(-1)
		- 举例：线程A追踪系统中的线程1、2、3，线程B追踪系统中的线程4、5、6，然后分别调用wait(-1)
		- 现象：线程A wait到了线程B所追踪的线程4的事件，线程B也会 wait到线程A所追踪的线程，但线程A、B均无法利用ptrace对追踪到的对方的事件进行处理
		- 举例：鉴于前者的现象，线程A、B均将wait(-1)改为waitid(P_PGID
                - 现象：当被监控的线程进行了fork，存在不监控新建进程组的问题，需要另外拉起一个线程去等待新创建的进程组，否则新的进程组会一直阻塞
	- 单个线程负责利用ptrace进行追踪、读取寄存器、放行，其它线程负责wait、通知主线程读取寄存器、拿到寄存器的参数进行分析和处理、通知主线程放行
- 多进程（当前主分支，经过验证，性能仍然低于预期）
	- 每个进程追踪系统中的一个进程组或多个进程组，通过额外拉起一个线程让监控进程追踪，以达到控制监控进程的目的
    - 这种方案的致命缺陷就是ptrace框架本身的设计问题，当被监控的某一个进程，后续又启动了大量的进程/线程,那么这些进程/线程的所有事件都会交由这一个监控进程进行处理，会产生瓶颈效应，除非做动态负载均衡（不确定会带来多大的性能提升）

## 优化思路（仅猜想）
- 动态负载均衡
    - 当某个进程的任务数量过多时，在SEIZE模式下，向部分被监控的进程/线程发送STOP信号后，取消对它们的追踪，并告知其它比较空闲的监控进程进行追踪
- 协程
	- 每个协程利用ptrace对系统中的部分线程进行追踪，随后分别调用wait(-1)
- c++ 20/23 或者libgo等相关库
- go 的原生协程与C/C++混编

## 说明及注意事项
### 说明
* PTRACE_POKEDATA：该标志用于将数据写入被跟踪进程的内存。
> 你可以使用它来修改进程的数据段（data segment）或堆（heap）中的任意内存位置。
>> 例如，你可以使用它来修改程序中的变量值或函数的参数。
 
* PTRACE_POKETEXT：该标志用于将指令写入被跟踪进程的内存。
> 你可以使用它来修改进程的代码段（text segment）中的指令。
> 通过修改指令，你可以实现一些代码注入或代码替换的操作。
> 这在进行动态调试或代码修复时可能会有用。
 
* PTRACE_POKEUSER：该标志用于修改被跟踪进程的用户寄存器（user registers）。
> 用户寄存器包括程序计数器（program counter）、堆栈指针（stack pointer）和其他一些与进程状态相关的寄存器。
> 通过修改这些寄存器的值，你可以对进程的执行流程进行精确控制，例如修改函数调用栈或返回地址等。

### 注意事项
#### 一：
- 当使用PTRACE_POKEDATA修改某个系统调用的字符串参数时，务必保证新字符串长度小于等于原字符串长度，否则会出现以下两种情况
	- 情况1：如果原字符串在数据段，新字符串长度超出，会导致破坏原数据段数据，或其它不可预知的错误，{就比如在我本地while循环中有{write，printf}，这两个系统调用使用的参数均在数据段，当我修改write使用的的新字符串长度超出原字符串长度的时候，就出现了不调用下一次的系统调用（printf）的问题}
	- 情况2：如果原字符串在堆区，新字符串长度超出，大概率会导致段错误

#### 二：
- 当被修改的数据在数据段
	- 修改会是永久的，只有在下次目标进程重新启动数据才会还原
	- 另外个人猜测如果是动态库的话，则需要使用该动态库的进程全部退出，系统将动态库从内存中释放，然后重新启动各个进程，将动态库重新加载进内存，数据才会被还原
- 当被修改的数据在堆区则有两种情况
	- 情况1：该堆区变量仅被赋值过一次，则现象与修改数据段数据一致
	- 情况2：该堆区变量被赋值过多次，则需要重复修改，才能保证该进程一直使用的是你所修改的数据

#### 三：
- 当被修改的数据是值拷贝传递，那么修改该数据不会影响程序下一次使用该参数
	- 就比如修改write函数中的参数1，也就是fd的值，并不会造成后续调用close导致文件描述符泄漏的问题

# PS
- 对于上述对被追踪的进程线程的描述中，由于内核中不存在线程的概念，应用层的线程实际时内核中的进程，应用层中的进程实际是内核中的进程组，故描述可能会有混淆，理解大概意思即可
